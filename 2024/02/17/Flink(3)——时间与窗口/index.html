
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8" theme-name="Stellar" theme-version="1.26.8">
  
  <meta name="generator" content="Hexo 7.1.1">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>Flink(2)——时间与窗口 - wangyang377_blog</title>

  
    <meta name="description" content="在批处理统计中，我们是等待一批数据都到齐后，统一处理。但是在实时处理统计中，我们是来一条就得处理一条，但是单条的意义很有限，我们会更想要统计一段时间内的数据。 这就需要引入“窗口”。 所谓的“窗口”，一般就是划定的一段时间范围，也就是“时间窗”；对在这范围内的数据进行处理，就是所谓的窗口计算。所以窗口和时间往往是分不开的。 本文将带大家了解一下Flink中的时间和窗口的应用。 主要分为4部分：">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink(2)——时间与窗口">
<meta property="og:url" content="https://wangyang377.github.io/2024/02/17/Flink(3)%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E7%AA%97%E5%8F%A3/index.html">
<meta property="og:site_name" content="wangyang377_blog">
<meta property="og:description" content="在批处理统计中，我们是等待一批数据都到齐后，统一处理。但是在实时处理统计中，我们是来一条就得处理一条，但是单条的意义很有限，我们会更想要统计一段时间内的数据。 这就需要引入“窗口”。 所谓的“窗口”，一般就是划定的一段时间范围，也就是“时间窗”；对在这范围内的数据进行处理，就是所谓的窗口计算。所以窗口和时间往往是分不开的。 本文将带大家了解一下Flink中的时间和窗口的应用。 主要分为4部分：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514499.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514874.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171516346.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171516917.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514959.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171550856.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171557879.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514884.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514902.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171558453.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171558458.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514653.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171558782.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514882.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514148.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514254.png">
<meta property="og:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514775.png">
<meta property="article:published_time" content="2024-02-17T07:59:27.254Z">
<meta property="article:modified_time" content="2024-02-17T08:01:39.923Z">
<meta property="article:author" content="wangyang377">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514499.png">
  
  
  
  

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.26.8">

  

  

  
  
</head>
<body>

<div class="l_body content tech" id="start" layout="post" ><aside class="l_left"><div class="sidebar-container">


<header class="header"><div class="logo-wrap"><a class="title" href="/"><div class="main" ff="title">wangyang377_blog</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">

<widget class="widget-wrapper toc single" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89"><span class="toc-text">1. 时间语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AA%97%E5%8F%A3%EF%BC%88window%EF%BC%89"><span class="toc-text">2. 窗口（window）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AA%97%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 窗口的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%AA%97%E5%8F%A3%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">2.2  窗口的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%AA%97%E5%8F%A3API%E6%A6%82%E8%A7%88"><span class="toc-text">2.3 窗口API概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E7%AA%97%E5%8F%A3%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-text">2.4 窗口分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3"><span class="toc-text">2.4.1 时间窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E8%AE%A1%E6%95%B0%E7%AA%97%E5%8F%A3"><span class="toc-text">2.4.2 计数窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">2.5 窗口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88reduce%E3%80%81aggregate%EF%BC%89"><span class="toc-text">增量聚合函数（reduce、aggregate）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#reduceFunction"><span class="toc-text">reduceFunction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#aggregateFunction"><span class="toc-text">aggregateFunction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E7%AE%80%E5%8D%95%E8%81%9A%E5%90%88%E6%96%B9%E6%B3%95"><span class="toc-text">预定义的简单聚合方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-text">全窗口函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%92%8C%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">增量聚合和全窗口函数结合使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-trigger%E3%80%81evictor"><span class="toc-text">2.6 trigger、evictor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B0%B4%E4%BD%8D%E7%BA%BF%EF%BC%88watermark%EF%BC%89"><span class="toc-text">3. 水位线（watermark）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="toc-text">什么是水位线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="toc-text">生成水位线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%B1%E5%BA%8F"><span class="toc-text">乱序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E4%BD%8D%E7%BA%BF%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">水位线的传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9F%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">迟到数据的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E8%BF%9F%E6%B0%B4%E5%8D%B0%E6%8E%A8%E8%BF%9B"><span class="toc-text">推迟水印推进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%AA%97%E5%8F%A3%E5%BB%B6%E8%BF%9F%E5%85%B3%E9%97%AD"><span class="toc-text">设置窗口延迟关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BE%A7%E6%B5%81%E6%8E%A5%E6%94%B6%E8%BF%9F%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">使用侧流接收迟到的数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E6%B5%81%E8%BF%9E%E6%8E%A5"><span class="toc-text">双流连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E8%81%94%E7%BB%93%EF%BC%88Window-Join%EF%BC%89"><span class="toc-text">窗口联结（Window Join）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E9%9A%94%E8%81%94%E7%BB%93%EF%BC%88Interval-Join%EF%BC%89"><span class="toc-text">间隔联结（Interval Join）</span></a></li></ol></li></ol></div></div></widget>







<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/2024/02/18/Flink(2)%E2%80%94%E2%80%94%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"><span class="title">Flink(2)——集群部署</span></a><a class="item title" href="/2024/02/18/Spark(1)%E2%80%94%E2%80%94wordcount/"><span class="title">Spark(1)——wordcount</span></a><a class="item title" href="/2024/02/17/Flink(4)%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81/"><span class="title">Flink(3)——状态</span></a><a class="item title active" href="/2024/02/17/Flink(3)%E2%80%94%E2%80%94%E6%97%B6%E9%97%B4%E4%B8%8E%E7%AA%97%E5%8F%A3/"><span class="title">Flink(2)——时间与窗口</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a><a class="item title" href="/2024/02/17/Flink(1)%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%EF%BC%9Awordcount/"><span class="title">Flink(1)——入门：wordcount</span></a><a class="item title" href="/2024/02/16/MapReduce%E2%80%94%E2%80%94countword/"><span class="title">MapReduce——countword</span></a><a class="item title" href="/2024/02/17/MapReduce%E2%80%94%E2%80%94join/"><span class="title">MapReduce——join</span></a><a class="item title" href="/2024/02/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAhadoop%E9%9B%86%E7%BE%A4/"><span class="title">从零开始搭建hadoop集群</span></a><a class="item title" href="/2024/02/15/%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%EF%BC%9Ahexo+gitpages+picgo+typora/"><span class="title">简易博客搭建：hexo+gitpages+picgo+typora</span></a></div></widget>
</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    
<div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a><span class="sep"></span><a class="cap breadcrumb-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/">大数据</a> <span class="sep"></span> <a class="cap breadcrumb-link" href="/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/Flink/">Flink</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-02-17T07:59:27.254Z">2024-02-17</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-02-17T08:01:39.923Z">2024-02-17</time></span></div></div>
</div>

    
    <div class="bottom">
      <div class="text-area">
        <h1 class="text title"><span>Flink(2)——时间与窗口</span></h1>
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>在批处理统计中，我们是等待一批数据都到齐后，统一处理。但是在实时处理统计中，我们是来一条就得处理一条，但是单条的意义很有限，我们会更想要统计一段时间内的数据。</p>
<p><strong>这就需要引入“窗口”。</strong></p>
<p>所谓的“窗口”，一般就是划定的一段时间范围，也就是“时间窗”；对在这范围内的数据进行处理，就是所谓的窗口计算。所以窗口和时间往往是分不开的。</p>
<p>本文将带大家了解一下Flink中的时间和窗口的应用。</p>
<p>主要分为4部分：</p>
<ul>
<li>时间语义：简单介绍flink中的时间语义</li>
<li>窗口：介绍窗口的概念和API</li>
<li>水位线：flink中的水位线概念</li>
<li>案例：最后完成一个双流Join的案例收尾</li>
</ul>
<p>主要是对 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1eg4y1V7AN/?share_source=copy_web&vd_source=734dd62020b0c9e8f3d0c98c588a56a3">尚硅谷大数据Flink1.17实战教程从入门到精通</a> 相关章节的整理</p>
<h2 id="1-时间语义"><a href="#1-时间语义" class="headerlink" title="1. 时间语义"></a>1. 时间语义</h2><p>因为存在网络延迟，所以flink中的事件时间和处理时间是不一样的</p>
<p>到底以哪一种时间作为衡量标准，就是所谓的“时间语义”</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514499.png" alt="img"></p>
<p><strong>在实际应用中，事件时间语义会更为常见</strong>。一般情况下，业务日志数据中都会记录数据生成的时间戳（timestamp），它就可以作为事件时间的判断基础。</p>
<p>在Flink中，由于处理时间比较简单，早期版本默认的时间语义是处理时间；而考虑到事件时间在实际应用中更为广泛，从Flink1.12版本开始，Flink已经将事件时间作为默认的时间语义了。</p>
<h2 id="2-窗口（window）"><a href="#2-窗口（window）" class="headerlink" title="2. 窗口（window）"></a>2. 窗口（window）</h2><h3 id="2-1-窗口的概念"><a href="#2-1-窗口的概念" class="headerlink" title="2.1 窗口的概念"></a><strong>2.1 窗口的概念</strong></h3><p>Flink是一种流式计算引擎，主要是来处理无界数据流的，数据源源不断、无穷无尽。想要更加方便高效地处理无界流，一种方式就是将无限数据切割成有限的“数据块”进行处理，这就是所谓的“窗口”（Window）</p>
<p><strong>注意：</strong>Flink中窗口并不是静态准备好的，而是动态创建——当有落在这个窗口区间范围的数据达到时，才创建对应的窗口。另外，这里我们认为到达窗口结束时间时，窗口就触发计算并关闭，事实上“触发计算”和“窗口关闭”两个行为也可以分开，这部分内容我们会在后面详述。</p>
<h3 id="2-2-窗口的分类"><a href="#2-2-窗口的分类" class="headerlink" title="2.2  窗口的分类"></a><strong>2.2  窗口的分类</strong></h3><p>窗口的应用非常灵活，我们可以使用各种不同类型的窗口来实现需求。接下来我们就从不同的角度，对Flink中内置的窗口做一个分类说明。</p>
<p><strong>1</strong>）按照驱动类型分类</p>
<ul>
<li>时间窗口：</li>
<li>计数窗口：</li>
</ul>
<p><strong>2</strong>）按照窗口分配数据的规则分类</p>
<p>根据分配数据的规则，窗口的具体实现可以分为4类：</p>
<ul>
<li><p>滚动窗口（Tumbling Window）</p>
<ul>
<li><p>窗口大小固定，窗口之间无重叠、无间隔</p>
</li>
<li><p>比如：<strong>每10分钟统计10分钟内所有订单数量</strong>，窗口大小就是10分钟，窗口之间无重叠、无间隔</p>
</li>
<li><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514874.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>滑动窗口（Sliding Window）</p>
<ul>
<li><p>窗口大小固定，但是窗口之间并非如滚动窗口一样首尾相接，存在重叠，称之为滑动步长</p>
</li>
<li><p>比如：<strong>每10分钟统计1个小时内的所有订单数量</strong>，窗口大小就是1小时，窗口之间有重叠，滑动步长10分钟</p>
</li>
<li><p>滚动窗口可以看成一种特殊的滑动窗口——窗口大小&#x3D;滑动步长</p>
</li>
<li><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171516346.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>会话窗口（Session Window）</p>
<ul>
<li><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171516917.png" alt="img"></li>
</ul>
</li>
<li><p>以及全局窗口（Global Window）</p>
</li>
</ul>
<h3 id="2-3-窗口API概览"><a href="#2-3-窗口API概览" class="headerlink" title="2.3 窗口API概览"></a>2.3 窗口API概览</h3><p>在定义窗口操作之前，首先需要确定，到底是基于按键分区（Keyed）的数据流KeyedStream来开窗，还是直接在没有按键分区的DataStream上开窗。也就是说，在调用窗口算子之前，是否有keyBy操作。</p>
<ul>
<li><p>按键分区窗口（Keyed Windows）</p>
<ul>
<li>经过按键分区keyBy操作后，数据流会按照key被分为多条逻辑流（logical streams），这就是KeyedStream。基于KeyedStream进行窗口操作时，窗口计算会在多个并行子任务上同时执行。相同key的数据会被发送到同一个并行子任务，而窗口操作会基于每个key进行单独的处理。所以可以认为，每个key上都定义了一组窗口，各自独立地进行统计计算。</li>
</ul>
</li>
<li><p>非按键分区（Non-Keyed Windows）</p>
<ul>
<li>如果没有进行keyBy，那么原始的DataStream就不会分成多条逻辑流。这时窗口逻辑只能在一个任务（task）上执行，就相当于并行度变成了1</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong>对于非按键分区的窗口操作，手动调大窗口算子的并行度也是无效的，windowAll本身就是一个非并行的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按键分区和非按键分区</span></span><br><span class="line"><span class="comment">//并行度=1</span></span><br><span class="line">listDataStreamSource.windowAll(……);</span><br><span class="line"><span class="comment">//每个key上都有一组窗口</span></span><br><span class="line">listDataStreamSource.keyBy(a-&gt;a).window(……);</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口操作主要有两个部分：窗口分配器（Window Assigners）和窗口函数（Window Functions）</span></span><br><span class="line"><span class="comment">//.window()方法需要传入一个窗口分配器，它指明了窗口的类型</span></span><br><span class="line"><span class="comment">//.aggregate()方法传入一个窗口函数作为参数，它用来定义窗口具体的处理逻辑</span></span><br><span class="line"><span class="comment">//窗口分配器有各种形式，而窗口函数的调用方法也不只.aggregate()一种，后文详细展开</span></span><br><span class="line">stream.keyBy(&lt;key selector&gt;)</span><br><span class="line">       .window(&lt;window assigner&gt;)</span><br><span class="line">       .aggregate(&lt;window function&gt;)</span><br></pre></td></tr></table></figure>



<h3 id="2-4-窗口分配器"><a href="#2-4-窗口分配器" class="headerlink" title="2.4 窗口分配器"></a>2.4 窗口分配器</h3><p>定义窗口分配器（Window Assigners）是构建窗口算子的第一步，它的作用就是定义数据应该被“分配”到哪个窗口。所以可以说，<strong>窗口分配器其实就是在指定窗口的类型。</strong></p>
<p>窗口分配器最通用的定义方式，就是调用.window()方法。这个方法需要传入一个WindowAssigner作为参数，返回WindowedStream。如果是非按键分区窗口，那么直接调用.windowAll()方法，同样传入一个WindowAssigner，返回的是AllWindowedStream。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(<span class="operator">&lt;</span>key selector<span class="operator">&gt;</span>)</span><br><span class="line">       .<span class="keyword">window</span>(<span class="operator">&lt;</span><span class="keyword">window</span> assigner<span class="operator">&gt;</span>)</span><br><span class="line">       .aggregate(<span class="operator">&lt;</span><span class="keyword">window</span> <span class="keyword">function</span><span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>



<p>窗口按照驱动类型可以分成时间窗口和计数窗口，而按照具体的分配规则，又有滚动窗口、滑动窗口、会话窗口、全局窗口四种。除去需要自定义的全局窗口外，其他常用的类型Flink中都给出了<strong>内置的分配器实现</strong>，我们可以方便地调用实现各种需求。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514959.png" alt="img"></p>
<h4 id="2-4-1-时间窗口"><a href="#2-4-1-时间窗口" class="headerlink" title="2.4.1 时间窗口"></a>2.4.1 时间窗口</h4><p>时间窗口是最常用的窗口类型，又可以细分为滚动、滑动和会话三种，结合两种时间语义，共有六种时间窗口</p>
<p>（1）滚动处理时间窗口</p>
<p>（2）滑动处理时间窗口</p>
<p>（3）会话处理时间窗口</p>
<p>（4）滚动事件时间窗口</p>
<p>窗口分配器由类TumblingEventTimeWindows提供，用法与滚动处理事件窗口完全一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">       .aggregate(...)</span><br></pre></td></tr></table></figure>

<p>（5）滑动事件时间窗口</p>
<p>窗口分配器由类SlidingEventTimeWindows提供，用法与滑动处理事件窗口完全一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)，Time.seconds(<span class="number">5</span>)))</span><br><span class="line">       .aggregate(...)</span><br></pre></td></tr></table></figure>

<p>（6）会话事件时间窗口</p>
<p>窗口分配器由类EventTimeSessionWindows提供，用法与处理事件会话窗口完全一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(EventTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">       .aggregate(...)</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-计数窗口"><a href="#2-4-2-计数窗口" class="headerlink" title="2.4.2 计数窗口"></a>2.4.2 计数窗口</h4><p>计数窗口概念非常简单，本身底层是基于全局窗口（Global Window）实现的。Flink为我们提供了非常方便的接口：直接调用.countWindow()方法。根据分配规则的不同，又可以分为滚动计数窗口和滑动计数窗口两类，下面我们就来看它们的具体实现。</p>
<p>（1）滚动计数窗口</p>
<p>滚动计数窗口只需要传入一个长整型的参数size，表示窗口的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .countWindow(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>我们定义了一个长度为10的滚动计数窗口，当窗口中元素数量达到10的时候，就会触发计算执行并关闭窗口。</p>
<p>（2）滑动计数窗口</p>
<p>与滚动计数窗口类似，不过需要在.countWindow()调用时传入两个参数：size和slide，前者表示窗口大小，后者表示滑动步长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .countWindow(<span class="number">10</span>，<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>我们定义了一个长度为10、滑动步长为3的滑动计数窗口。每个窗口统计10个数据，每隔3个数据就统计输出一次结果。</p>
<p>注意：第一次输出是在第三个数据来时触发，而不是第10个</p>
<p>例如：0,1,2,3……9,在0,1,2之后就触发窗口输出</p>
<p>3）全局窗口</p>
<p>全局窗口是计数窗口的底层实现，一般在需要自定义窗口时使用。它的定义同样是直接调用.window()，分配器由GlobalWindows类提供。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">       .window(GlobalWindows.create());</span><br></pre></td></tr></table></figure>

<p>需要注意使用全局窗口，必须自行定义触发器才能实现窗口计算，否则起不到任何作用。</p>
<h3 id="2-5-窗口函数"><a href="#2-5-窗口函数" class="headerlink" title="2.5 窗口函数"></a>2.5 窗口函数</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171550856.png" alt="img"></p>
<h4 id="增量聚合函数（reduce、aggregate）"><a href="#增量聚合函数（reduce、aggregate）" class="headerlink" title="增量聚合函数（reduce、aggregate）"></a>增量聚合函数（reduce、aggregate）</h4><p>窗口将数据收集起来，最基本的处理操作当然就是进行聚合。我们可以每来一个数据就在之前结果上聚合一次，这就是“增量聚合”</p>
<p>典型的增量聚合函数有两个：ReduceFunction和AggregateFunction。</p>
<h5 id="reduceFunction"><a href="#reduceFunction" class="headerlink" title="reduceFunction"></a>reduceFunction</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">window</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置并行度为2</span></span><br><span class="line">        env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; map = source.map(a -&gt; Integer.parseInt(a));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照奇偶分组，同一组一定在同一个分区</span></span><br><span class="line">        KeyedStream&lt;Integer, Integer&gt; keyedStream = map.keyBy(a -&gt; a % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置5秒的窗口</span></span><br><span class="line">        WindowedStream&lt;Integer, Integer, TimeWindow&gt; window = keyedStream.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">5</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reduce function，简单的累加操作</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; reduced = window.reduce((a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">        reduced.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来讲，ReduceFunction可以解决大多数归约聚合的问题，但是这个接口有一个限制，就是聚合状态的类型、输出结果的类型都必须和输入数据类型一样。</p>
<p>而aggregate就突破了这个限制，可以定义更加灵活的窗口聚合操作。这个方法需要传入一个AggregateFunction的实现类作为参数。</p>
<h5 id="aggregateFunction"><a href="#aggregateFunction" class="headerlink" title="aggregateFunction"></a>aggregateFunction</h5><p>AggregateFunction可以看作是ReduceFunction的通用版本，这里有三种类型：输入类型（IN）、累加器类型（ACC）和输出类型（OUT）。输入类型IN就是输入流中元素的数据类型；累加器类型ACC则是我们进行聚合的中间状态类型；而输出类型当然就是最终计算结果的类型了。</p>
<p>接口中有四个方法：</p>
<ul>
<li>createAccumulator()：创建一个累加器，这就是为聚合创建了一个初始状态，每个聚合任务只会调用一次。</li>
<li>add()：将输入的元素添加到累加器中。</li>
<li>getResult()：从累加器中提取聚合的输出结果。</li>
<li>merge()：合并两个累加器，并将合并后的状态作为一个累加器返回。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">window</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置并行度为2</span></span><br><span class="line">        env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; map = source.map(a -&gt; Integer.parseInt(a));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照奇偶分组，同一组一定在同一个分区</span></span><br><span class="line">        KeyedStream&lt;Integer, Integer&gt; keyedStream = map.keyBy(a -&gt; a % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置5秒的窗口</span></span><br><span class="line">        WindowedStream&lt;Integer, Integer, TimeWindow&gt; window = keyedStream.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">5</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; aggregate = window.aggregate(</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 三个变量：IN，ACC，OUT</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">AggregateFunction</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//初始化acc</span></span><br><span class="line">                System.out.println(<span class="string">&quot;createAcc&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">(Integer value, Integer accumulator)</span> &#123;</span><br><span class="line">                <span class="comment">//这里的add和reduce的add不同，因为两个参数是value和acc，而reduce的两个参数都是value，所以reduce要等第二个输入进入才触发add，但是agg是一个输入就可以触发add</span></span><br><span class="line">                System.out.println(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> value + accumulator;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">getResult</span><span class="params">(Integer accumulator)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;getResult&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> accumulator;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">merge</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;merge&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        aggregate.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以可以看到，AggregateFunction的工作原理是：</p>
<ul>
<li>首先调用createAccumulator()为任务初始化一个状态（累加器）；</li>
<li>而后每来一个数据就调用一次add()方法，对数据进行聚合，得到的结果保存在状态中；</li>
<li>等到了窗口需要输出时，再调用getResult()方法得到计算结果。</li>
</ul>
<p>与ReduceFunction相同，AggregateFunction也是增量式的聚合；但由于输入、中间状态、输出的类型可以不同，使得应用更加灵活方便。</p>
<h5 id="预定义的简单聚合方法"><a href="#预定义的简单聚合方法" class="headerlink" title="预定义的简单聚合方法"></a>预定义的简单聚合方法</h5><p>Flink也为窗口的聚合提供了一系列预定义的简单聚合方法，可以直接基于WindowedStream调用。主要包括.sum()&#x2F;max()&#x2F;maxBy()&#x2F;min()&#x2F;minBy()，与KeyedStream的简单聚合非常相似。它们的底层，其实都是通过AggregateFunction来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">window</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置并行度为2</span></span><br><span class="line">        env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; map = source.map(a -&gt; Integer.parseInt(a));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照奇偶分组，同一组一定在同一个分区</span></span><br><span class="line">        KeyedStream&lt;Integer, Integer&gt; keyedStream = map.keyBy(a -&gt; a % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置10秒的窗口</span></span><br><span class="line">        WindowedStream&lt;Integer, Integer, TimeWindow&gt; window = keyedStream.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//max传入的参数表示比较列的下标</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; max = window.max(<span class="number">0</span>);</span><br><span class="line">        max.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全窗口函数"><a href="#全窗口函数" class="headerlink" title="全窗口函数"></a>全窗口函数</h4><p>有些场景下，我们要做的计算必须基于全部的数据才有效，这时做增量聚合就没什么意义了；另外，输出的结果有可能要包含上下文中的一些信息（比如窗口的起始时间），这是增量聚合函数做不到的。</p>
<p>所以，我们还需要有更丰富的窗口计算方式。窗口操作中的另一大类就是全窗口函数。与增量聚合函数不同，全窗口函数需要先收集窗口中的数据，并在内部缓存起来，等到窗口要输出结果的时候再取出数据进行计算。</p>
<p>例如：1+1+1+1+1+1</p>
<p>增量聚合是不断累加，1+1&#x3D;2+1&#x3D;3+1&#x3D;4+1&#x3D;5</p>
<p>全窗口是先把窗口中的数据缓存起来，一起计算：1+1+1+1+1&#x3D;5</p>
<p>在Flink中，全窗口函数也有两种：WindowFunction和ProcessWindowFunction。</p>
<p>不过WindowFunction能提供的上下文信息较少，也没有更高级的功能，逐渐被processWindowFunction淘汰，本文主要介绍processwindowfunction</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">window</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置并行度为2</span></span><br><span class="line">        env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; map = source.map(a -&gt; Integer.parseInt(a));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照奇偶分组，同一组一定在同一个分区</span></span><br><span class="line">        KeyedStream&lt;Integer, Integer&gt; keyedStream = map.keyBy(a -&gt; a % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置10秒的窗口</span></span><br><span class="line">        WindowedStream&lt;Integer, Integer, TimeWindow&gt; window = keyedStream.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 全窗口函数，窗口触发时才会统一触发一次</span></span><br><span class="line"><span class="comment">         * Base abstract class for functions that are evaluated over keyed (grouped) windows using a context</span></span><br><span class="line"><span class="comment">         * for retrieving extra information.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;IN&gt; The type of the input value.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;OUT&gt; The type of the output value.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;KEY&gt; The type of the key.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;W&gt; The type of &#123;<span class="doctag">@code</span> Window&#125; that this window function can be applied on.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = window.process(<span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;Integer, String, Integer, TimeWindow&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> integer The key for which this window is evaluated. 分组的key</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> context The context in which the window is being evaluated. 上下文</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> elements The elements in the window being evaluated. 存的数据</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> out A collector for emitting elements. 采集器</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Integer integer, ProcessWindowFunction&lt;Integer, String, Integer, TimeWindow&gt;.Context context, Iterable&lt;Integer&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> context.window().getStart();</span><br><span class="line">                <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> context.window().getEnd();</span><br><span class="line">                <span class="type">String</span> <span class="variable">startF</span> <span class="operator">=</span> DateFormatUtils.format(start, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">endF</span> <span class="operator">=</span> DateFormatUtils.format(end, <span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line">                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();</span><br><span class="line"></span><br><span class="line">                out.collect(<span class="string">&quot;key=:&quot;</span> + integer + <span class="string">&quot;,窗口：&quot;</span> + startF + <span class="string">&quot; &quot;</span> + endF+<span class="string">&quot;,包含数据条数：&quot;</span>+count);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        process.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171557879.png" alt="img"></p>
<h4 id="增量聚合和全窗口函数结合使用"><a href="#增量聚合和全窗口函数结合使用" class="headerlink" title="增量聚合和全窗口函数结合使用"></a>增量聚合和全窗口函数结合使用</h4><p>所有的增量聚合函数都可以在原来的reducefuction之外，再传递一个processwindowfunction，这样数据会先经过增量聚和得到一个结果，再到全窗口函数进行封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReduceFunction与WindowFunction结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title function_">reduce</span><span class="params">(</span></span><br><span class="line"><span class="params">        ReduceFunction&lt;T&gt; reduceFunction，WindowFunction&lt;T，R，K，W&gt; function)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// ReduceFunction与ProcessWindowFunction结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title function_">reduce</span><span class="params">(</span></span><br><span class="line"><span class="params">        ReduceFunction&lt;T&gt; reduceFunction，ProcessWindowFunction&lt;T，R，K，W&gt; function)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AggregateFunction与WindowFunction结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;ACC，V，R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title function_">aggregate</span><span class="params">(</span></span><br><span class="line"><span class="params">        AggregateFunction&lt;T，ACC，V&gt; aggFunction，WindowFunction&lt;V，R，K，W&gt; windowFunction)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AggregateFunction与ProcessWindowFunction结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;ACC，V，R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title function_">aggregate</span><span class="params">(</span></span><br><span class="line"><span class="params">        AggregateFunction&lt;T，ACC，V&gt; aggFunction,</span></span><br><span class="line"><span class="params">        ProcessWindowFunction&lt;V，R，K，W&gt; windowFunction)</span></span><br></pre></td></tr></table></figure>



<p>这样调用的处理机制是：</p>
<ul>
<li>基于第一个参数（增量聚合函数）来处理窗口数据，每来一个数据就做一次聚合</li>
<li>等到窗口需要触发计算时，则调用第二个参数（全窗口函数）的处理逻辑输出结果</li>
<li>注意：这里的全窗口函数就不再缓存所有数据了，而是直接将增量聚合函数的结果拿来当作了Iterable类型的输入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">agg</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置并行度为2</span></span><br><span class="line">        env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; map = source.map(a -&gt; Integer.parseInt(a));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照奇偶分组，同一组一定在同一个分区</span></span><br><span class="line">        KeyedStream&lt;Integer, Integer&gt; keyedStream = map.keyBy(a -&gt; a % <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置10秒的窗口</span></span><br><span class="line">        WindowedStream&lt;Integer, Integer, TimeWindow&gt; window = keyedStream.window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; aggregate = window.aggregate(<span class="keyword">new</span> <span class="title class_">AggregateFunction</span>&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;createAcc&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">(Integer value, Integer accumulator)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> accumulator + value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">getResult</span><span class="params">(Integer accumulator)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;getResult&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> accumulator;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">merge</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;Integer, String, Integer, TimeWindow&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Integer integer, ProcessWindowFunction&lt;Integer, String, Integer, TimeWindow&gt;.Context context, Iterable&lt;Integer&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> context.window().getStart();</span><br><span class="line">                <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> context.window().getEnd();</span><br><span class="line">                <span class="type">String</span> <span class="variable">startF</span> <span class="operator">=</span> DateFormatUtils.format(start, <span class="string">&quot;yyyy-MM-dd HH-mm-ss.SS&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">endF</span> <span class="operator">=</span> DateFormatUtils.format(end, <span class="string">&quot;yyyy-MM-dd HH-mm-ss.SS&quot;</span>);</span><br><span class="line">                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();</span><br><span class="line"></span><br><span class="line">                out.collect(<span class="string">&quot;窗口：&quot;</span> + startF + <span class="string">&quot; &quot;</span> + endF +  <span class="string">&quot;,key:&quot;</span> + integer + <span class="string">&quot;,窗口内数据量：&quot;</span> + count+<span class="string">&quot;,数据值：&quot;</span>+elements.toString());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        aggregate.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514884.png" alt="img"></p>
<h3 id="2-6-trigger、evictor"><a href="#2-6-trigger、evictor" class="headerlink" title="2.6 trigger、evictor"></a>2.6 trigger、evictor</h3><p>常用的几个窗口都有默认的实现，一般不需要自定义</p>
<h2 id="3-水位线（watermark）"><a href="#3-水位线（watermark）" class="headerlink" title="3. 水位线（watermark）"></a>3. 水位线（watermark）</h2><p>在窗口的处理过程中，我们可以基于数据的时间戳，自定义一个“<strong>逻辑时钟</strong>”。这个时钟的时间不会自动流逝；它的时间进展，就是靠着新到数据的时间戳来推动的。</p>
<p>这样的好处在于，计算的过程可以完全不依赖处理时间（系统时间），不论什么时候进行统计处理，得到的结果都是正确的。而一般实时流处理的场景中，事件时间可以基本与处理时间保持同步，只是略微有一点延迟，同时保证了窗口计算的正确性。</p>
<h3 id="什么是水位线"><a href="#什么是水位线" class="headerlink" title="什么是水位线"></a>什么是水位线</h3><p>在Flink中，用来衡量事件时间进展的标记，就被称作“水位线”（Watermark）。</p>
<p>具体实现上，水位线可以看作一条特殊的数据记录，它是插入到数据流中的一个标记点，主要内容就是一个时间戳，用来指示当前的事件时间。而它插入流中的位置，就应该是在某个数据到来之后；这样就可以从这个数据中提取时间戳，作为当前水位线的时间戳了。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514902.png" alt="img"></p>
<p>水位线面临的首要问题就是数据流几乎不可能都是从小到大的有序流，乱序+迟到数据是不可避免的</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171558453.png" alt="img"></p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171558458.png" alt="img"></p>
<p>总结：</p>
<ul>
<li>水位线是插入到数据流中的一个标记，可以认为是一个特殊的数据</li>
<li>水位线主要的内容是一个时间戳，用来表示当前事件时间的进展</li>
<li>水位线是基于数据的时间戳生成的</li>
<li>水位线的时间戳必须单调递增，以确保任务的事件时间时钟一直向前推进</li>
<li>水位线可以通过设置延迟，来保证正确处理乱序数据</li>
<li>一个水位线Watermark(t),表示在当前流中事件时间已经达到了时间戳t,这代表t之前的所</li>
<li>有数据都到齐了，之后流中不会出现时间戳≤的数据</li>
<li>水位线是Fk流处理中保证结果正确性的核心机制，它往往会跟窗口一起配合，完成对乱序数据的正确处理</li>
</ul>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514653.png" alt="img"></p>
<p>注意: 水位线是触发窗口关闭的，窗口的创建是按照到达数据的事件时间动态创建的</p>
<h3 id="生成水位线"><a href="#生成水位线" class="headerlink" title="生成水位线"></a>生成水位线</h3><p>在Flink的DataStream API中，有一个单独用于生成水位线的方法：.assignTimestampsAndWatermarks()，它主要用来为流中的数据分配时间戳，并生成水位线来指示事件时间。具体使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> <span class="title class_">ClickSource</span>());</span><br><span class="line"></span><br><span class="line">DataStream&lt;Event&gt; withTimestampsAndWatermarks = </span><br><span class="line">stream.assignTimestampsAndWatermarks(&lt;watermark strategy&gt;);</span><br></pre></td></tr></table></figure>

<p>说明：WatermarkStrategy作为参数，这就是所谓的“水位线生成策略”。WatermarkStrategy是一个接口，该接口中包含了一个“时间戳分配器”TimestampAssigner和一个“水位线生成器”WatermarkGenerator。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WatermarkStrategy</span>&lt;T&gt; </span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">TimestampAssignerSupplier</span>&lt;T&gt;,</span><br><span class="line">            WatermarkGeneratorSupplier&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责从流中数据元素的某个字段中提取时间戳，并分配给元素。时间戳的分配是生成水位线的基础。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    TimestampAssigner&lt;T&gt; <span class="title function_">createTimestampAssigner</span><span class="params">(TimestampAssignerSupplier.Context context)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要负责按照既定的方式，基于时间戳生成水位线</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    WatermarkGenerator&lt;T&gt; <span class="title function_">createWatermarkGenerator</span><span class="params">(WatermarkGeneratorSupplier.Context context)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：测试水位线时最好把并行度设置为1，不然思路会很乱</p>
<p><strong>传入一个tuple，提取f1作为timestamp</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">watermark</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置并行度为1</span></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, String&gt;&gt; map = source.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Tuple2&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tuple2&lt;String, String&gt; <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                String[] split = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Tuple2.of(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        WatermarkStrategy&lt;Tuple2&lt;String, String&gt;&gt; ws = WatermarkStrategy</span><br><span class="line">                <span class="comment">//升序的watermark，没有等待时间</span></span><br><span class="line">                <span class="comment">//需要指定tuple类型</span></span><br><span class="line">                .&lt;Tuple2&lt;String, String&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                <span class="comment">//指定timestamp提取逻辑</span></span><br><span class="line">                .withTimestampAssigner(<span class="keyword">new</span> <span class="title class_">SerializableTimestampAssigner</span>&lt;Tuple2&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">extractTimestamp</span><span class="params">(Tuple2&lt;String, String&gt; element, <span class="type">long</span> recordTimestamp)</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;数据：&quot;</span> + element + <span class="string">&quot;,timestamp：&quot;</span> + recordTimestamp);</span><br><span class="line">                        <span class="keyword">return</span> Integer.parseInt(element.f1) * <span class="number">1000L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="comment">//        WatermarkStrategy&lt;Tuple2&lt;String, String&gt;&gt; ws = WatermarkStrategy.&lt;Tuple2&lt;String, String&gt;&gt;forMonotonousTimestamps()</span></span><br><span class="line"><span class="comment">//                                                                        .withTimestampAssigner((data, time) -&gt; Integer.parseInt(data.f1) * 1000L);</span></span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, String&gt;&gt; mapWM = map.assignTimestampsAndWatermarks(ws);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里需要使用事件时间</span></span><br><span class="line">        WindowedStream&lt;Tuple2&lt;String, String&gt;, String, TimeWindow&gt; window = mapWM.keyBy(a -&gt; a.f0)</span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = window.process(<span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;Tuple2&lt;String, String&gt;, String, String, TimeWindow&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, ProcessWindowFunction&lt;Tuple2&lt;String, String&gt;, String, String, TimeWindow&gt;.Context context, Iterable&lt;Tuple2&lt;String, String&gt;&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> context.window().getStart();</span><br><span class="line">                <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> context.window().getEnd();</span><br><span class="line">                <span class="type">String</span> <span class="variable">startF</span> <span class="operator">=</span> DateFormatUtils.format(start, <span class="string">&quot;yyyy-MM-dd HH:MM:ss.SS&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">endF</span> <span class="operator">=</span> DateFormatUtils.format(end, <span class="string">&quot;yyyy-MM-dd HH:MM:ss.SS&quot;</span>);</span><br><span class="line">                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;触发窗口:&quot;</span>+startF+<span class="string">&quot; &quot;</span>+endF+<span class="string">&quot;, &quot;</span>+elements.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="乱序"><a href="#乱序" class="headerlink" title="乱序"></a>乱序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.protocol.types.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">watermark</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置并行度为2</span></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, String&gt;&gt; map = source.map(<span class="keyword">new</span> <span class="title class_">MapFunction</span>&lt;String, Tuple2&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Tuple2&lt;String, String&gt; <span class="title function_">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                String[] split = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> Tuple2.of(split[<span class="number">0</span>],split[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延迟时间3s</span></span><br><span class="line">        WatermarkStrategy&lt;Tuple2&lt;String, String&gt;&gt; ws = WatermarkStrategy.&lt;Tuple2&lt;String, String&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))</span><br><span class="line">                .withTimestampAssigner((data, time) -&gt; Integer.parseInt(data.f1) * <span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, String&gt;&gt; mapWM = map.assignTimestampsAndWatermarks(ws);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里需要使用事件时间</span></span><br><span class="line">        WindowedStream&lt;Tuple2&lt;String, String&gt;, String, TimeWindow&gt; window = mapWM.keyBy(a -&gt; a.f0)</span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = window.process(<span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;Tuple2&lt;String, String&gt;, String, String, TimeWindow&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, ProcessWindowFunction&lt;Tuple2&lt;String, String&gt;, String, String, TimeWindow&gt;.Context context, Iterable&lt;Tuple2&lt;String, String&gt;&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> context.window().getStart();</span><br><span class="line">                <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> context.window().getEnd();</span><br><span class="line">                <span class="type">String</span> <span class="variable">startF</span> <span class="operator">=</span> DateFormatUtils.format(start, <span class="string">&quot;yyyy-MM-dd HH:MM:ss.SS&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">endF</span> <span class="operator">=</span> DateFormatUtils.format(end, <span class="string">&quot;yyyy-MM-dd HH:MM:ss.SS&quot;</span>);</span><br><span class="line">                <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> elements.spliterator().estimateSize();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;触发窗口:&quot;</span>+startF+<span class="string">&quot; &quot;</span>+endF+<span class="string">&quot;, &quot;</span>+elements.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171558782.png" alt="img"></h4><h3 id="水位线的传递"><a href="#水位线的传递" class="headerlink" title="水位线的传递"></a>水位线的传递</h3><p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514882.png" alt="img"></p>
<p>在流处理中，上游任务处理完水位线、时钟改变之后，要把当前的水位线再次发出，广播给所有的下游子任务。而当一个任务接收到多个上游并行任务传递来的水位线时，应该以最小的那个作为当前任务的事件时钟。</p>
<p>当然这也带来一个问题。</p>
<p>在多个上游并行任务中，如果有其中一个没有数据，由于当前Task是以最小的那个作为当前任务的事件时钟，就会导致当前Task的水位线无法推进，就可能导致窗口无法触发。这时候可以设置空闲等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateFormatUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.SerializableTimestampAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.WindowedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.ProcessWindowFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingProcessingTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.WindowAssigner;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.protocol.types.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">watermark</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env=StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">//设置并行度为2</span></span><br><span class="line">        env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取流数据</span></span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分区，让数据按照奇偶分别进入0和1分区</span></span><br><span class="line">        <span class="comment">//这样只输入奇数，则map只有一个分区是有数据的，另一个分区一直是空，这样算子从map获取的水位线一直是最小值，不会触发窗口</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; map = source.partitionCustom(<span class="keyword">new</span> <span class="title class_">Partitioner</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(String s, <span class="type">int</span> numPartitions)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前数字：&quot;</span>+s+<span class="string">&quot;,分区数&quot;</span>+numPartitions+<span class="string">&quot;，进入分区：&quot;</span>+Integer.parseInt(s)%<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">return</span> Integer.parseInt(s) % <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,a-&gt;a).map(a -&gt; Integer.parseInt(a));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//水位线生成策略</span></span><br><span class="line">        WatermarkStrategy&lt;Integer&gt; ws = WatermarkStrategy.&lt;Integer&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))</span><br><span class="line">                .withTimestampAssigner((a, ts) -&gt; a * <span class="number">1000L</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如不设置空闲等待，窗口一直不会触发</span></span><br><span class="line">                .withIdleness(Duration.ofSeconds(<span class="number">5</span>));<span class="comment">//空闲等待五秒</span></span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; watermarks = map.assignTimestampsAndWatermarks(ws);</span><br><span class="line">        <span class="comment">//这里需要使用事件时间</span></span><br><span class="line">        WindowedStream&lt;Integer, Integer, TimeWindow&gt; window = watermarks.keyBy(a -&gt; a % <span class="number">2</span>).window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)));</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Integer&gt; wd = window.process(<span class="keyword">new</span> <span class="title class_">ProcessWindowFunction</span>&lt;Integer, Integer, Integer, TimeWindow&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Integer integer, ProcessWindowFunction&lt;Integer, Integer, Integer, TimeWindow&gt;.Context context, Iterable&lt;Integer&gt; elements, Collector&lt;Integer&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;触发窗口&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如不设置空闲等待，则运行如下图</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WatermarkStrategy&lt;Integer&gt; ws = WatermarkStrategy.&lt;Integer&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))</span><br><span class="line">        .withTimestampAssigner((a, ts) -&gt; a * <span class="number">1000L</span>)</span><br><span class="line">        <span class="comment">//如不设置空闲等待，窗口一直不会触发</span></span><br><span class="line">        <span class="comment">//.withIdleness(Duration.ofSeconds(5));//空闲等待五秒</span></span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514148.png" alt="img"></p>
<h3 id="迟到数据的处理"><a href="#迟到数据的处理" class="headerlink" title="迟到数据的处理"></a><strong>迟到数据的处理</strong></h3><h4 id="推迟水印推进"><a href="#推迟水印推进" class="headerlink" title="推迟水印推进"></a>推迟水印推进</h4><p>在水印产生时，设置一个乱序容忍度，推迟系统时间的推进，保证窗口计算被延迟执行，为乱序的数据争取更多的时间进入窗口。</p>
<p>WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(10));</p>
<h4 id="设置窗口延迟关闭"><a href="#设置窗口延迟关闭" class="headerlink" title="设置窗口延迟关闭"></a>设置窗口延迟关闭</h4><p> Flink的窗口，也允许迟到数据。当触发了窗口计算后，会先计算当前的结果，但是此时并不会关闭窗口。</p>
<p>以后每来一条迟到数据，就触发一次这条数据所在窗口计算(增量计算)。直到wartermark 超过了窗口结束时间+推迟时间，此时窗口会真正关闭。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">.allowedLateness(Time.seconds(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<p>允许迟到只能运用在event time上</p>
<h4 id="使用侧流接收迟到的数据"><a href="#使用侧流接收迟到的数据" class="headerlink" title="使用侧流接收迟到的数据"></a>使用侧流接收迟到的数据</h4><h2 id="双流连接"><a href="#双流连接" class="headerlink" title="双流连接"></a>双流连接</h2><h3 id="窗口联结（Window-Join）"><a href="#窗口联结（Window-Join）" class="headerlink" title="窗口联结（Window Join）"></a><strong>窗口联结（Window Join）</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1.join(stream2)</span><br><span class="line">        .where(&lt;KeySelector&gt;)</span><br><span class="line">        .equalTo(&lt;KeySelector&gt;)</span><br><span class="line">        .window(&lt;WindowAssigner&gt;)</span><br><span class="line">        .apply(&lt;JoinFunction&gt;)</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.JoinFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">windowjoin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; ds1 = env</span><br><span class="line">                .fromElements(</span><br><span class="line">                        Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                        Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>),</span><br><span class="line">                        Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>),</span><br><span class="line">                        Tuple2.of(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>)</span><br><span class="line">                )</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy</span><br><span class="line">                                .&lt;Tuple2&lt;String, Integer&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, Integer,Integer&gt;&gt; ds2 = env</span><br><span class="line">                .fromElements(</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="number">11</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="number">12</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;c&quot;</span>, <span class="number">14</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;d&quot;</span>, <span class="number">15</span>,<span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy</span><br><span class="line">                                .&lt;Tuple3&lt;String, Integer,Integer&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)</span><br><span class="line">                );</span><br><span class="line">        </span><br><span class="line">        DataStream&lt;String&gt; apply = ds1.join(ds2).where(a -&gt; a.f0).equalTo(b -&gt; b.f0).window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>))).apply(<span class="keyword">new</span> <span class="title class_">JoinFunction</span>&lt;Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, Integer, Integer&gt;, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">join</span><span class="params">(Tuple2&lt;String, Integer&gt; first, Tuple3&lt;String, Integer, Integer&gt; second)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">return</span> first + <span class="string">&quot;====&quot;</span> + second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        apply.print();</span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514254.png" alt="img"></p>
<h3 id="间隔联结（Interval-Join）"><a href="#间隔联结（Interval-Join）" class="headerlink" title="间隔联结（Interval Join）"></a><strong>间隔联结（Interval Join）</strong></h3><p>窗口连接是双方都在同一个窗口内才会发生链接，但是如果出现a在9s，b在11s，两条数据就匹配不上了，显然不符合现实要求，所以更推荐使用间隔联结</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.githubusercontent.com/wangyang377/blogImages/main/202402171514775.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.JoinFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.ProcessJoinFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">windowjoin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        DataStreamSource&lt;String&gt; source = env.socketTextStream(<span class="string">&quot;node1&quot;</span>, <span class="number">7777</span>);</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; ds1 = env</span><br><span class="line">                .fromElements(</span><br><span class="line">                        Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                        Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>),</span><br><span class="line">                        Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>),</span><br><span class="line">                        Tuple2.of(<span class="string">&quot;c&quot;</span>, <span class="number">4</span>)</span><br><span class="line">                )</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy</span><br><span class="line">                                .&lt;Tuple2&lt;String, Integer&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, Integer,Integer&gt;&gt; ds2 = env</span><br><span class="line">                .fromElements(</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="number">11</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="number">12</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;c&quot;</span>, <span class="number">14</span>,<span class="number">1</span>),</span><br><span class="line">                        Tuple3.of(<span class="string">&quot;d&quot;</span>, <span class="number">15</span>,<span class="number">1</span>)</span><br><span class="line">                )</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy</span><br><span class="line">                                .&lt;Tuple3&lt;String, Integer,Integer&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; d1 = ds1.keyBy(a -&gt; a.f0);</span><br><span class="line">        KeyedStream&lt;Tuple3&lt;String, Integer, Integer&gt;, String&gt; d2 = ds2.keyBy(a -&gt; a.f0);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = d1.intervalJoin(d2).between(Time.seconds(-<span class="number">2</span>), Time.seconds(<span class="number">2</span>))</span><br><span class="line">                .process(<span class="keyword">new</span> <span class="title class_">ProcessJoinFunction</span>&lt;Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, Integer, Integer&gt;, String&gt;() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 两条流数据匹配上才会触发</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> left The left element of the joined pair.</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> right The right element of the joined pair.</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> ctx A context that allows querying the timestamps of the left, right and joined pair.</span></span><br><span class="line"><span class="comment">                     *     In addition, this context allows to emit elements on a side output.</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> out The collector to emit resulting elements to.</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(Tuple2&lt;String, Integer&gt; left, Tuple3&lt;String, Integer, Integer&gt; right, ProcessJoinFunction&lt;Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, Integer, Integer&gt;, String&gt;.Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        System.out.println(left + <span class="string">&quot;====&quot;</span> + right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        process.print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迟到数据的处理：outputTag</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.eventtime.WatermarkStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.JoinFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.KeyedStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.ProcessJoinFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.OutputTag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">windowjoin</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; ds1 = env.socketTextStream(<span class="string">&quot;node1&quot;</span>,<span class="number">7777</span>).map(a-&gt;&#123;</span><br><span class="line">            String[] split = a.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(split[<span class="number">0</span>],Integer.parseInt(split[<span class="number">1</span>]));</span><br><span class="line">        &#125;).returns(Types.TUPLE(Types.STRING,Types.INT))</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                WatermarkStrategy.</span><br><span class="line">                        &lt;Tuple2&lt;String,Integer&gt;&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))</span><br><span class="line">                        .withTimestampAssigner((a,r)-&gt;a.f1*<span class="number">1000L</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, Integer,Integer&gt;&gt; ds2 = env</span><br><span class="line">                .socketTextStream(<span class="string">&quot;node1&quot;</span>,<span class="number">8888</span>).map(a-&gt;&#123;</span><br><span class="line">                    String[] split = a.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> Tuple3.of(split[<span class="number">0</span>],Integer.parseInt(split[<span class="number">1</span>]),Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">                &#125;).returns(Types.TUPLE(Types.STRING,Types.INT,Types.INT))</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy</span><br><span class="line">                                .&lt;Tuple3&lt;String, Integer,Integer&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                                .withTimestampAssigner((value, ts) -&gt; value.f1 * <span class="number">1000L</span>)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; d1 = ds1.keyBy(a -&gt; a.f0);</span><br><span class="line">        KeyedStream&lt;Tuple3&lt;String, Integer, Integer&gt;, String&gt; d2 = ds2.keyBy(a -&gt; a.f0);</span><br><span class="line"></span><br><span class="line">        OutputTag&lt;Tuple3&lt;String, Integer, Integer&gt;&gt; rightLate = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;&gt;(<span class="string">&quot;rightLate&quot;</span>, Types.TUPLE(Types.STRING, Types.INT, Types.INT));</span><br><span class="line">        OutputTag&lt;Tuple2&lt;String, Integer&gt;&gt; leftLate = <span class="keyword">new</span> <span class="title class_">OutputTag</span>&lt;&gt;(<span class="string">&quot;leftLate&quot;</span>, Types.TUPLE(Types.STRING, Types.INT));</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; process = d1.intervalJoin(d2).between(Time.seconds(-<span class="number">2</span>), Time.seconds(<span class="number">2</span>))</span><br><span class="line">                .sideOutputRightLateData(rightLate)</span><br><span class="line">                .sideOutputLeftLateData(leftLate)</span><br><span class="line">                .process(<span class="keyword">new</span> <span class="title class_">ProcessJoinFunction</span>&lt;Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, Integer, Integer&gt;, String&gt;() &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 两条流数据匹配上才会触发</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> left The left element of the joined pair.</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> right The right element of the joined pair.</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> ctx A context that allows querying the timestamps of the left, right and joined pair.</span></span><br><span class="line"><span class="comment">                     *     In addition, this context allows to emit elements on a side output.</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@param</span> out The collector to emit resulting elements to.</span></span><br><span class="line"><span class="comment">                     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processElement</span><span class="params">(Tuple2&lt;String, Integer&gt; left, Tuple3&lt;String, Integer, Integer&gt; right, ProcessJoinFunction&lt;Tuple2&lt;String, Integer&gt;, Tuple3&lt;String, Integer, Integer&gt;, String&gt;.Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        out.collect(left + <span class="string">&quot;====&quot;</span> + right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        process.print(<span class="string">&quot;主流&quot;</span>);</span><br><span class="line">        process.getSideOutput(rightLate).printToErr(<span class="string">&quot;rightlate&quot;</span>);</span><br><span class="line">        process.getSideOutput(leftLate).printToErr(<span class="string">&quot;leftlate&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/2024/02/17/Flink(4)%E2%80%94%E2%80%94%E7%8A%B6%E6%80%81/">Flink(3)——状态</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/02/17/Flink(1)%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8%EF%BC%9Awordcount/">Flink(1)——入门：wordcount</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">wangyang377</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8">Stellar 1.26.8</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
<div class="main-mask" onclick="sidebar.toggle()"></div></div></div><div class="scripts">
<script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.26.8';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.26.8';
  stellar.config = {
    date_suffix: {
      just: '刚刚',
      min: '分钟前',
      hour: '小时前',
      day: '天前',
      month: '个月前',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js","memos":"/js/plugins/memos.js","marked":"/js/plugins/marked.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js","transition":"fade"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@10.3/swiper-bundle.min.css","js":"https://unpkg.com/swiper@10.3/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://cdn.bootcdn.net/ajax/libs/scrollReveal.js/4.0.9/scrollreveal.min.js","distance":"16px","duration":800,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","flying_pages":"https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js","css":"https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css","selector":null});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied","toast":"复制成功"});
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.26.8" async></script>

<!-- optional -->






<!-- inject -->

</div></body></html>
